// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'schema.schema.gql.dart';

// **************************************************************************
// BuiltValueGenerator
// **************************************************************************

const GAllowUploadFileType _$gAllowUploadFileTypeGIF =
    const GAllowUploadFileType._('GIF');
const GAllowUploadFileType _$gAllowUploadFileTypeJPG =
    const GAllowUploadFileType._('JPG');
const GAllowUploadFileType _$gAllowUploadFileTypeMP3 =
    const GAllowUploadFileType._('MP3');
const GAllowUploadFileType _$gAllowUploadFileTypeMP4 =
    const GAllowUploadFileType._('MP4');
const GAllowUploadFileType _$gAllowUploadFileTypeOGG =
    const GAllowUploadFileType._('OGG');
const GAllowUploadFileType _$gAllowUploadFileTypePNG =
    const GAllowUploadFileType._('PNG');
const GAllowUploadFileType _$gAllowUploadFileTypeWAV =
    const GAllowUploadFileType._('WAV');

GAllowUploadFileType _$gAllowUploadFileTypeValueOf(String name) {
  switch (name) {
    case 'GIF':
      return _$gAllowUploadFileTypeGIF;
    case 'JPG':
      return _$gAllowUploadFileTypeJPG;
    case 'MP3':
      return _$gAllowUploadFileTypeMP3;
    case 'MP4':
      return _$gAllowUploadFileTypeMP4;
    case 'OGG':
      return _$gAllowUploadFileTypeOGG;
    case 'PNG':
      return _$gAllowUploadFileTypePNG;
    case 'WAV':
      return _$gAllowUploadFileTypeWAV;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GAllowUploadFileType> _$gAllowUploadFileTypeValues =
    new BuiltSet<GAllowUploadFileType>(const <GAllowUploadFileType>[
  _$gAllowUploadFileTypeGIF,
  _$gAllowUploadFileTypeJPG,
  _$gAllowUploadFileTypeMP3,
  _$gAllowUploadFileTypeMP4,
  _$gAllowUploadFileTypeOGG,
  _$gAllowUploadFileTypePNG,
  _$gAllowUploadFileTypeWAV,
]);

const GMomentMediaType _$gMomentMediaTypeAUDIO =
    const GMomentMediaType._('AUDIO');
const GMomentMediaType _$gMomentMediaTypeIMAGE =
    const GMomentMediaType._('IMAGE');
const GMomentMediaType _$gMomentMediaTypeVIDEO =
    const GMomentMediaType._('VIDEO');

GMomentMediaType _$gMomentMediaTypeValueOf(String name) {
  switch (name) {
    case 'AUDIO':
      return _$gMomentMediaTypeAUDIO;
    case 'IMAGE':
      return _$gMomentMediaTypeIMAGE;
    case 'VIDEO':
      return _$gMomentMediaTypeVIDEO;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GMomentMediaType> _$gMomentMediaTypeValues =
    new BuiltSet<GMomentMediaType>(const <GMomentMediaType>[
  _$gMomentMediaTypeAUDIO,
  _$gMomentMediaTypeIMAGE,
  _$gMomentMediaTypeVIDEO,
]);

const GMomentScalarFieldEnum _$gMomentScalarFieldEnumcontent =
    const GMomentScalarFieldEnum._('content');
const GMomentScalarFieldEnum _$gMomentScalarFieldEnumcreatedAt =
    const GMomentScalarFieldEnum._('createdAt');
const GMomentScalarFieldEnum _$gMomentScalarFieldEnumdeletedAt =
    const GMomentScalarFieldEnum._('deletedAt');
const GMomentScalarFieldEnum _$gMomentScalarFieldEnumid =
    const GMomentScalarFieldEnum._('id');
const GMomentScalarFieldEnum _$gMomentScalarFieldEnummedia =
    const GMomentScalarFieldEnum._('media');
const GMomentScalarFieldEnum _$gMomentScalarFieldEnumownerId =
    const GMomentScalarFieldEnum._('ownerId');
const GMomentScalarFieldEnum _$gMomentScalarFieldEnumtitle =
    const GMomentScalarFieldEnum._('title');

GMomentScalarFieldEnum _$gMomentScalarFieldEnumValueOf(String name) {
  switch (name) {
    case 'content':
      return _$gMomentScalarFieldEnumcontent;
    case 'createdAt':
      return _$gMomentScalarFieldEnumcreatedAt;
    case 'deletedAt':
      return _$gMomentScalarFieldEnumdeletedAt;
    case 'id':
      return _$gMomentScalarFieldEnumid;
    case 'media':
      return _$gMomentScalarFieldEnummedia;
    case 'ownerId':
      return _$gMomentScalarFieldEnumownerId;
    case 'title':
      return _$gMomentScalarFieldEnumtitle;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GMomentScalarFieldEnum> _$gMomentScalarFieldEnumValues =
    new BuiltSet<GMomentScalarFieldEnum>(const <GMomentScalarFieldEnum>[
  _$gMomentScalarFieldEnumcontent,
  _$gMomentScalarFieldEnumcreatedAt,
  _$gMomentScalarFieldEnumdeletedAt,
  _$gMomentScalarFieldEnumid,
  _$gMomentScalarFieldEnummedia,
  _$gMomentScalarFieldEnumownerId,
  _$gMomentScalarFieldEnumtitle,
]);

const GQueryMode _$gQueryModeGdefault = const GQueryMode._('Gdefault');
const GQueryMode _$gQueryModeinsensitive = const GQueryMode._('insensitive');

GQueryMode _$gQueryModeValueOf(String name) {
  switch (name) {
    case 'Gdefault':
      return _$gQueryModeGdefault;
    case 'insensitive':
      return _$gQueryModeinsensitive;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GQueryMode> _$gQueryModeValues =
    new BuiltSet<GQueryMode>(const <GQueryMode>[
  _$gQueryModeGdefault,
  _$gQueryModeinsensitive,
]);

const GUserSecurityCompareType _$gUserSecurityCompareTypePASSWORD =
    const GUserSecurityCompareType._('PASSWORD');
const GUserSecurityCompareType _$gUserSecurityCompareTypePHONE_SMS_CODE =
    const GUserSecurityCompareType._('PHONE_SMS_CODE');

GUserSecurityCompareType _$gUserSecurityCompareTypeValueOf(String name) {
  switch (name) {
    case 'PASSWORD':
      return _$gUserSecurityCompareTypePASSWORD;
    case 'PHONE_SMS_CODE':
      return _$gUserSecurityCompareTypePHONE_SMS_CODE;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GUserSecurityCompareType> _$gUserSecurityCompareTypeValues =
    new BuiltSet<GUserSecurityCompareType>(const <GUserSecurityCompareType>[
  _$gUserSecurityCompareTypePASSWORD,
  _$gUserSecurityCompareTypePHONE_SMS_CODE,
]);

const GsortOrder _$gsortOrderasc = const GsortOrder._('asc');
const GsortOrder _$gsortOrderdesc = const GsortOrder._('desc');

GsortOrder _$gsortOrderValueOf(String name) {
  switch (name) {
    case 'asc':
      return _$gsortOrderasc;
    case 'desc':
      return _$gsortOrderdesc;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GsortOrder> _$gsortOrderValues =
    new BuiltSet<GsortOrder>(const <GsortOrder>[
  _$gsortOrderasc,
  _$gsortOrderdesc,
]);

Serializer<GAllowUploadFileType> _$gAllowUploadFileTypeSerializer =
    new _$GAllowUploadFileTypeSerializer();
Serializer<GDateTimeFilter> _$gDateTimeFilterSerializer =
    new _$GDateTimeFilterSerializer();
Serializer<GMomentMediaType> _$gMomentMediaTypeSerializer =
    new _$GMomentMediaTypeSerializer();
Serializer<GMomentOrderByInput> _$gMomentOrderByInputSerializer =
    new _$GMomentOrderByInputSerializer();
Serializer<GMomentScalarFieldEnum> _$gMomentScalarFieldEnumSerializer =
    new _$GMomentScalarFieldEnumSerializer();
Serializer<GMomentWhereInput> _$gMomentWhereInputSerializer =
    new _$GMomentWhereInputSerializer();
Serializer<GMomentWhereUniqueInput> _$gMomentWhereUniqueInputSerializer =
    new _$GMomentWhereUniqueInputSerializer();
Serializer<GQueryMode> _$gQueryModeSerializer = new _$GQueryModeSerializer();
Serializer<GStringFilter> _$gStringFilterSerializer =
    new _$GStringFilterSerializer();
Serializer<GUserOrderByInput> _$gUserOrderByInputSerializer =
    new _$GUserOrderByInputSerializer();
Serializer<GUserProfileOrderByInput> _$gUserProfileOrderByInputSerializer =
    new _$GUserProfileOrderByInputSerializer();
Serializer<GUserProfileRelationFilter> _$gUserProfileRelationFilterSerializer =
    new _$GUserProfileRelationFilterSerializer();
Serializer<GUserProfileUpdateInput> _$gUserProfileUpdateInputSerializer =
    new _$GUserProfileUpdateInputSerializer();
Serializer<GUserProfileWhereInput> _$gUserProfileWhereInputSerializer =
    new _$GUserProfileWhereInputSerializer();
Serializer<GUserRelationFilter> _$gUserRelationFilterSerializer =
    new _$GUserRelationFilterSerializer();
Serializer<GUserSecurityCompareType> _$gUserSecurityCompareTypeSerializer =
    new _$GUserSecurityCompareTypeSerializer();
Serializer<GUserWhereInput> _$gUserWhereInputSerializer =
    new _$GUserWhereInputSerializer();
Serializer<GUserWhereUniqueInput> _$gUserWhereUniqueInputSerializer =
    new _$GUserWhereUniqueInputSerializer();
Serializer<GsortOrder> _$gsortOrderSerializer = new _$GsortOrderSerializer();

class _$GAllowUploadFileTypeSerializer
    implements PrimitiveSerializer<GAllowUploadFileType> {
  @override
  final Iterable<Type> types = const <Type>[GAllowUploadFileType];
  @override
  final String wireName = 'GAllowUploadFileType';

  @override
  Object serialize(Serializers serializers, GAllowUploadFileType object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GAllowUploadFileType deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GAllowUploadFileType.valueOf(serialized as String);
}

class _$GDateTimeFilterSerializer
    implements StructuredSerializer<GDateTimeFilter> {
  @override
  final Iterable<Type> types = const [GDateTimeFilter, _$GDateTimeFilter];
  @override
  final String wireName = 'GDateTimeFilter';

  @override
  Iterable<Object?> serialize(Serializers serializers, GDateTimeFilter object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.equals;
    if (value != null) {
      result
        ..add('equals')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDateTime)));
    }
    value = object.gt;
    if (value != null) {
      result
        ..add('gt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDateTime)));
    }
    value = object.gte;
    if (value != null) {
      result
        ..add('gte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDateTime)));
    }
    value = object.Gin;
    if (value != null) {
      result
        ..add('in')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(GDateTime)])));
    }
    value = object.lt;
    if (value != null) {
      result
        ..add('lt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDateTime)));
    }
    value = object.lte;
    if (value != null) {
      result
        ..add('lte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDateTime)));
    }
    value = object.not;
    if (value != null) {
      result
        ..add('not')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDateTimeFilter)));
    }
    value = object.notIn;
    if (value != null) {
      result
        ..add('notIn')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(GDateTime)])));
    }
    return result;
  }

  @override
  GDateTimeFilter deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GDateTimeFilterBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'equals':
          result.equals.replace(serializers.deserialize(value,
              specifiedType: const FullType(GDateTime))! as GDateTime);
          break;
        case 'gt':
          result.gt.replace(serializers.deserialize(value,
              specifiedType: const FullType(GDateTime))! as GDateTime);
          break;
        case 'gte':
          result.gte.replace(serializers.deserialize(value,
              specifiedType: const FullType(GDateTime))! as GDateTime);
          break;
        case 'in':
          result.Gin.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GDateTime)]))!
              as BuiltList<Object>);
          break;
        case 'lt':
          result.lt.replace(serializers.deserialize(value,
              specifiedType: const FullType(GDateTime))! as GDateTime);
          break;
        case 'lte':
          result.lte.replace(serializers.deserialize(value,
              specifiedType: const FullType(GDateTime))! as GDateTime);
          break;
        case 'not':
          result.not.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GDateTimeFilter))!
              as GDateTimeFilter);
          break;
        case 'notIn':
          result.notIn.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GDateTime)]))!
              as BuiltList<Object>);
          break;
      }
    }

    return result.build();
  }
}

class _$GMomentMediaTypeSerializer
    implements PrimitiveSerializer<GMomentMediaType> {
  @override
  final Iterable<Type> types = const <Type>[GMomentMediaType];
  @override
  final String wireName = 'GMomentMediaType';

  @override
  Object serialize(Serializers serializers, GMomentMediaType object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GMomentMediaType deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GMomentMediaType.valueOf(serialized as String);
}

class _$GMomentOrderByInputSerializer
    implements StructuredSerializer<GMomentOrderByInput> {
  @override
  final Iterable<Type> types = const [
    GMomentOrderByInput,
    _$GMomentOrderByInput
  ];
  @override
  final String wireName = 'GMomentOrderByInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GMomentOrderByInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.content;
    if (value != null) {
      result
        ..add('content')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.createdAt;
    if (value != null) {
      result
        ..add('createdAt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.deletedAt;
    if (value != null) {
      result
        ..add('deletedAt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.media;
    if (value != null) {
      result
        ..add('media')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.owner;
    if (value != null) {
      result
        ..add('owner')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GUserOrderByInput)));
    }
    value = object.ownerId;
    if (value != null) {
      result
        ..add('ownerId')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    return result;
  }

  @override
  GMomentOrderByInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GMomentOrderByInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'content':
          result.content = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'createdAt':
          result.createdAt = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'deletedAt':
          result.deletedAt = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'media':
          result.media = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'owner':
          result.owner.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GUserOrderByInput))!
              as GUserOrderByInput);
          break;
        case 'ownerId':
          result.ownerId = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'title':
          result.title = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
      }
    }

    return result.build();
  }
}

class _$GMomentScalarFieldEnumSerializer
    implements PrimitiveSerializer<GMomentScalarFieldEnum> {
  @override
  final Iterable<Type> types = const <Type>[GMomentScalarFieldEnum];
  @override
  final String wireName = 'GMomentScalarFieldEnum';

  @override
  Object serialize(Serializers serializers, GMomentScalarFieldEnum object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GMomentScalarFieldEnum deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GMomentScalarFieldEnum.valueOf(serialized as String);
}

class _$GMomentWhereInputSerializer
    implements StructuredSerializer<GMomentWhereInput> {
  @override
  final Iterable<Type> types = const [GMomentWhereInput, _$GMomentWhereInput];
  @override
  final String wireName = 'GMomentWhereInput';

  @override
  Iterable<Object?> serialize(Serializers serializers, GMomentWhereInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.AND;
    if (value != null) {
      result
        ..add('AND')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(GMomentWhereInput)])));
    }
    value = object.NOT;
    if (value != null) {
      result
        ..add('NOT')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(GMomentWhereInput)])));
    }
    value = object.OR;
    if (value != null) {
      result
        ..add('OR')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(GMomentWhereInput)])));
    }
    value = object.content;
    if (value != null) {
      result
        ..add('content')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    value = object.createdAt;
    if (value != null) {
      result
        ..add('createdAt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDateTimeFilter)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    value = object.owner;
    if (value != null) {
      result
        ..add('owner')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GUserRelationFilter)));
    }
    value = object.ownerId;
    if (value != null) {
      result
        ..add('ownerId')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    return result;
  }

  @override
  GMomentWhereInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GMomentWhereInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'AND':
          result.AND.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GMomentWhereInput)]))!
              as BuiltList<Object>);
          break;
        case 'NOT':
          result.NOT.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GMomentWhereInput)]))!
              as BuiltList<Object>);
          break;
        case 'OR':
          result.OR.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GMomentWhereInput)]))!
              as BuiltList<Object>);
          break;
        case 'content':
          result.content.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
        case 'createdAt':
          result.createdAt.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GDateTimeFilter))!
              as GDateTimeFilter);
          break;
        case 'id':
          result.id.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
        case 'owner':
          result.owner.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GUserRelationFilter))!
              as GUserRelationFilter);
          break;
        case 'ownerId':
          result.ownerId.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
        case 'title':
          result.title.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
      }
    }

    return result.build();
  }
}

class _$GMomentWhereUniqueInputSerializer
    implements StructuredSerializer<GMomentWhereUniqueInput> {
  @override
  final Iterable<Type> types = const [
    GMomentWhereUniqueInput,
    _$GMomentWhereUniqueInput
  ];
  @override
  final String wireName = 'GMomentWhereUniqueInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GMomentWhereUniqueInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  GMomentWhereUniqueInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GMomentWhereUniqueInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
      }
    }

    return result.build();
  }
}

class _$GQueryModeSerializer implements PrimitiveSerializer<GQueryMode> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'Gdefault': 'default',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'default': 'Gdefault',
  };

  @override
  final Iterable<Type> types = const <Type>[GQueryMode];
  @override
  final String wireName = 'GQueryMode';

  @override
  Object serialize(Serializers serializers, GQueryMode object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  GQueryMode deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GQueryMode.valueOf(_fromWire[serialized] ?? serialized as String);
}

class _$GStringFilterSerializer implements StructuredSerializer<GStringFilter> {
  @override
  final Iterable<Type> types = const [GStringFilter, _$GStringFilter];
  @override
  final String wireName = 'GStringFilter';

  @override
  Iterable<Object?> serialize(Serializers serializers, GStringFilter object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.contains;
    if (value != null) {
      result
        ..add('contains')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.endsWith;
    if (value != null) {
      result
        ..add('endsWith')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.equals;
    if (value != null) {
      result
        ..add('equals')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.gt;
    if (value != null) {
      result
        ..add('gt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.gte;
    if (value != null) {
      result
        ..add('gte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.Gin;
    if (value != null) {
      result
        ..add('in')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(String)])));
    }
    value = object.lt;
    if (value != null) {
      result
        ..add('lt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.lte;
    if (value != null) {
      result
        ..add('lte')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.mode;
    if (value != null) {
      result
        ..add('mode')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GQueryMode)));
    }
    value = object.not;
    if (value != null) {
      result
        ..add('not')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    value = object.notIn;
    if (value != null) {
      result
        ..add('notIn')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(String)])));
    }
    value = object.startsWith;
    if (value != null) {
      result
        ..add('startsWith')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  GStringFilter deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GStringFilterBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'contains':
          result.contains = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'endsWith':
          result.endsWith = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'equals':
          result.equals = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'gt':
          result.gt = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'gte':
          result.gte = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'in':
          result.Gin.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(String)]))!
              as BuiltList<Object>);
          break;
        case 'lt':
          result.lt = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'lte':
          result.lte = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'mode':
          result.mode = serializers.deserialize(value,
              specifiedType: const FullType(GQueryMode)) as GQueryMode;
          break;
        case 'not':
          result.not.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
        case 'notIn':
          result.notIn.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(String)]))!
              as BuiltList<Object>);
          break;
        case 'startsWith':
          result.startsWith = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
      }
    }

    return result.build();
  }
}

class _$GUserOrderByInputSerializer
    implements StructuredSerializer<GUserOrderByInput> {
  @override
  final Iterable<Type> types = const [GUserOrderByInput, _$GUserOrderByInput];
  @override
  final String wireName = 'GUserOrderByInput';

  @override
  Iterable<Object?> serialize(Serializers serializers, GUserOrderByInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.createdAt;
    if (value != null) {
      result
        ..add('createdAt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.password;
    if (value != null) {
      result
        ..add('password')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.phone;
    if (value != null) {
      result
        ..add('phone')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.profile;
    if (value != null) {
      result
        ..add('profile')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GUserProfileOrderByInput)));
    }
    value = object.username;
    if (value != null) {
      result
        ..add('username')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    return result;
  }

  @override
  GUserOrderByInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUserOrderByInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'createdAt':
          result.createdAt = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'password':
          result.password = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'phone':
          result.phone = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'profile':
          result.profile.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GUserProfileOrderByInput))!
              as GUserProfileOrderByInput);
          break;
        case 'username':
          result.username = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
      }
    }

    return result.build();
  }
}

class _$GUserProfileOrderByInputSerializer
    implements StructuredSerializer<GUserProfileOrderByInput> {
  @override
  final Iterable<Type> types = const [
    GUserProfileOrderByInput,
    _$GUserProfileOrderByInput
  ];
  @override
  final String wireName = 'GUserProfileOrderByInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GUserProfileOrderByInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.avatar;
    if (value != null) {
      result
        ..add('avatar')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.bio;
    if (value != null) {
      result
        ..add('bio')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.location;
    if (value != null) {
      result
        ..add('location')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.name;
    if (value != null) {
      result
        ..add('name')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.updatedAt;
    if (value != null) {
      result
        ..add('updatedAt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    value = object.userId;
    if (value != null) {
      result
        ..add('userId')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GsortOrder)));
    }
    return result;
  }

  @override
  GUserProfileOrderByInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUserProfileOrderByInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'avatar':
          result.avatar = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'bio':
          result.bio = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'location':
          result.location = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'name':
          result.name = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'updatedAt':
          result.updatedAt = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
        case 'userId':
          result.userId = serializers.deserialize(value,
              specifiedType: const FullType(GsortOrder)) as GsortOrder;
          break;
      }
    }

    return result.build();
  }
}

class _$GUserProfileRelationFilterSerializer
    implements StructuredSerializer<GUserProfileRelationFilter> {
  @override
  final Iterable<Type> types = const [
    GUserProfileRelationFilter,
    _$GUserProfileRelationFilter
  ];
  @override
  final String wireName = 'GUserProfileRelationFilter';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GUserProfileRelationFilter object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.Gis;
    if (value != null) {
      result
        ..add('is')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GUserProfileWhereInput)));
    }
    value = object.isNot;
    if (value != null) {
      result
        ..add('isNot')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GUserProfileWhereInput)));
    }
    return result;
  }

  @override
  GUserProfileRelationFilter deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUserProfileRelationFilterBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'is':
          result.Gis.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GUserProfileWhereInput))!
              as GUserProfileWhereInput);
          break;
        case 'isNot':
          result.isNot.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GUserProfileWhereInput))!
              as GUserProfileWhereInput);
          break;
      }
    }

    return result.build();
  }
}

class _$GUserProfileUpdateInputSerializer
    implements StructuredSerializer<GUserProfileUpdateInput> {
  @override
  final Iterable<Type> types = const [
    GUserProfileUpdateInput,
    _$GUserProfileUpdateInput
  ];
  @override
  final String wireName = 'GUserProfileUpdateInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GUserProfileUpdateInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.avatar;
    if (value != null) {
      result
        ..add('avatar')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.bio;
    if (value != null) {
      result
        ..add('bio')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.location;
    if (value != null) {
      result
        ..add('location')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.name;
    if (value != null) {
      result
        ..add('name')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  GUserProfileUpdateInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUserProfileUpdateInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'avatar':
          result.avatar = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'bio':
          result.bio = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'location':
          result.location = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'name':
          result.name = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
      }
    }

    return result.build();
  }
}

class _$GUserProfileWhereInputSerializer
    implements StructuredSerializer<GUserProfileWhereInput> {
  @override
  final Iterable<Type> types = const [
    GUserProfileWhereInput,
    _$GUserProfileWhereInput
  ];
  @override
  final String wireName = 'GUserProfileWhereInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GUserProfileWhereInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.AND;
    if (value != null) {
      result
        ..add('AND')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(GUserProfileWhereInput)])));
    }
    value = object.NOT;
    if (value != null) {
      result
        ..add('NOT')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(GUserProfileWhereInput)])));
    }
    value = object.OR;
    if (value != null) {
      result
        ..add('OR')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(GUserProfileWhereInput)])));
    }
    value = object.avatar;
    if (value != null) {
      result
        ..add('avatar')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    value = object.bio;
    if (value != null) {
      result
        ..add('bio')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    value = object.location;
    if (value != null) {
      result
        ..add('location')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    value = object.name;
    if (value != null) {
      result
        ..add('name')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    value = object.user;
    if (value != null) {
      result
        ..add('user')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GUserRelationFilter)));
    }
    value = object.userId;
    if (value != null) {
      result
        ..add('userId')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    return result;
  }

  @override
  GUserProfileWhereInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUserProfileWhereInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'AND':
          result.AND.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(GUserProfileWhereInput)
              ]))! as BuiltList<Object>);
          break;
        case 'NOT':
          result.NOT.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(GUserProfileWhereInput)
              ]))! as BuiltList<Object>);
          break;
        case 'OR':
          result.OR.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(GUserProfileWhereInput)
              ]))! as BuiltList<Object>);
          break;
        case 'avatar':
          result.avatar.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
        case 'bio':
          result.bio.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
        case 'location':
          result.location.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
        case 'name':
          result.name.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
        case 'user':
          result.user.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GUserRelationFilter))!
              as GUserRelationFilter);
          break;
        case 'userId':
          result.userId.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
      }
    }

    return result.build();
  }
}

class _$GUserRelationFilterSerializer
    implements StructuredSerializer<GUserRelationFilter> {
  @override
  final Iterable<Type> types = const [
    GUserRelationFilter,
    _$GUserRelationFilter
  ];
  @override
  final String wireName = 'GUserRelationFilter';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GUserRelationFilter object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.Gis;
    if (value != null) {
      result
        ..add('is')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GUserWhereInput)));
    }
    value = object.isNot;
    if (value != null) {
      result
        ..add('isNot')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GUserWhereInput)));
    }
    return result;
  }

  @override
  GUserRelationFilter deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUserRelationFilterBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'is':
          result.Gis.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GUserWhereInput))!
              as GUserWhereInput);
          break;
        case 'isNot':
          result.isNot.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GUserWhereInput))!
              as GUserWhereInput);
          break;
      }
    }

    return result.build();
  }
}

class _$GUserSecurityCompareTypeSerializer
    implements PrimitiveSerializer<GUserSecurityCompareType> {
  @override
  final Iterable<Type> types = const <Type>[GUserSecurityCompareType];
  @override
  final String wireName = 'GUserSecurityCompareType';

  @override
  Object serialize(Serializers serializers, GUserSecurityCompareType object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GUserSecurityCompareType deserialize(
          Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GUserSecurityCompareType.valueOf(serialized as String);
}

class _$GUserWhereInputSerializer
    implements StructuredSerializer<GUserWhereInput> {
  @override
  final Iterable<Type> types = const [GUserWhereInput, _$GUserWhereInput];
  @override
  final String wireName = 'GUserWhereInput';

  @override
  Iterable<Object?> serialize(Serializers serializers, GUserWhereInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.AND;
    if (value != null) {
      result
        ..add('AND')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(GUserWhereInput)])));
    }
    value = object.NOT;
    if (value != null) {
      result
        ..add('NOT')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(GUserWhereInput)])));
    }
    value = object.OR;
    if (value != null) {
      result
        ..add('OR')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(GUserWhereInput)])));
    }
    value = object.createdAt;
    if (value != null) {
      result
        ..add('createdAt')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDateTimeFilter)));
    }
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    value = object.moments;
    if (value != null) {
      result
        ..add('moments')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GUserProfileRelationFilter)));
    }
    value = object.phone;
    if (value != null) {
      result
        ..add('phone')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    value = object.profile;
    if (value != null) {
      result
        ..add('profile')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GUserProfileRelationFilter)));
    }
    value = object.username;
    if (value != null) {
      result
        ..add('username')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GStringFilter)));
    }
    return result;
  }

  @override
  GUserWhereInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUserWhereInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'AND':
          result.AND.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GUserWhereInput)]))!
              as BuiltList<Object>);
          break;
        case 'NOT':
          result.NOT.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GUserWhereInput)]))!
              as BuiltList<Object>);
          break;
        case 'OR':
          result.OR.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GUserWhereInput)]))!
              as BuiltList<Object>);
          break;
        case 'createdAt':
          result.createdAt.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GDateTimeFilter))!
              as GDateTimeFilter);
          break;
        case 'id':
          result.id.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
        case 'moments':
          result.moments.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GUserProfileRelationFilter))!
              as GUserProfileRelationFilter);
          break;
        case 'phone':
          result.phone.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
        case 'profile':
          result.profile.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GUserProfileRelationFilter))!
              as GUserProfileRelationFilter);
          break;
        case 'username':
          result.username.replace(serializers.deserialize(value,
              specifiedType: const FullType(GStringFilter))! as GStringFilter);
          break;
      }
    }

    return result.build();
  }
}

class _$GUserWhereUniqueInputSerializer
    implements StructuredSerializer<GUserWhereUniqueInput> {
  @override
  final Iterable<Type> types = const [
    GUserWhereUniqueInput,
    _$GUserWhereUniqueInput
  ];
  @override
  final String wireName = 'GUserWhereUniqueInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GUserWhereUniqueInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.id;
    if (value != null) {
      result
        ..add('id')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.phone;
    if (value != null) {
      result
        ..add('phone')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.username;
    if (value != null) {
      result
        ..add('username')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  GUserWhereUniqueInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUserWhereUniqueInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'phone':
          result.phone = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'username':
          result.username = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
      }
    }

    return result.build();
  }
}

class _$GsortOrderSerializer implements PrimitiveSerializer<GsortOrder> {
  @override
  final Iterable<Type> types = const <Type>[GsortOrder];
  @override
  final String wireName = 'GsortOrder';

  @override
  Object serialize(Serializers serializers, GsortOrder object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GsortOrder deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GsortOrder.valueOf(serialized as String);
}

class _$GDateTime extends GDateTime {
  @override
  final String value;

  factory _$GDateTime([void Function(GDateTimeBuilder)? updates]) =>
      (new GDateTimeBuilder()..update(updates)).build();

  _$GDateTime._({required this.value}) : super._() {
    BuiltValueNullFieldError.checkNotNull(value, 'GDateTime', 'value');
  }

  @override
  GDateTime rebuild(void Function(GDateTimeBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GDateTimeBuilder toBuilder() => new GDateTimeBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GDateTime && value == other.value;
  }

  @override
  int get hashCode {
    return $jf($jc(0, value.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GDateTime')..add('value', value))
        .toString();
  }
}

class GDateTimeBuilder implements Builder<GDateTime, GDateTimeBuilder> {
  _$GDateTime? _$v;

  String? _value;
  String? get value => _$this._value;
  set value(String? value) => _$this._value = value;

  GDateTimeBuilder();

  GDateTimeBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _value = $v.value;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GDateTime other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GDateTime;
  }

  @override
  void update(void Function(GDateTimeBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GDateTime build() {
    final _$result = _$v ??
        new _$GDateTime._(
            value: BuiltValueNullFieldError.checkNotNull(
                value, 'GDateTime', 'value'));
    replace(_$result);
    return _$result;
  }
}

class _$GDateTimeFilter extends GDateTimeFilter {
  @override
  final GDateTime? equals;
  @override
  final GDateTime? gt;
  @override
  final GDateTime? gte;
  @override
  final BuiltList<GDateTime>? Gin;
  @override
  final GDateTime? lt;
  @override
  final GDateTime? lte;
  @override
  final GDateTimeFilter? not;
  @override
  final BuiltList<GDateTime>? notIn;

  factory _$GDateTimeFilter([void Function(GDateTimeFilterBuilder)? updates]) =>
      (new GDateTimeFilterBuilder()..update(updates)).build();

  _$GDateTimeFilter._(
      {this.equals,
      this.gt,
      this.gte,
      this.Gin,
      this.lt,
      this.lte,
      this.not,
      this.notIn})
      : super._();

  @override
  GDateTimeFilter rebuild(void Function(GDateTimeFilterBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GDateTimeFilterBuilder toBuilder() =>
      new GDateTimeFilterBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GDateTimeFilter &&
        equals == other.equals &&
        gt == other.gt &&
        gte == other.gte &&
        Gin == other.Gin &&
        lt == other.lt &&
        lte == other.lte &&
        not == other.not &&
        notIn == other.notIn;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc($jc($jc(0, equals.hashCode), gt.hashCode),
                            gte.hashCode),
                        Gin.hashCode),
                    lt.hashCode),
                lte.hashCode),
            not.hashCode),
        notIn.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GDateTimeFilter')
          ..add('equals', equals)
          ..add('gt', gt)
          ..add('gte', gte)
          ..add('Gin', Gin)
          ..add('lt', lt)
          ..add('lte', lte)
          ..add('not', not)
          ..add('notIn', notIn))
        .toString();
  }
}

class GDateTimeFilterBuilder
    implements Builder<GDateTimeFilter, GDateTimeFilterBuilder> {
  _$GDateTimeFilter? _$v;

  GDateTimeBuilder? _equals;
  GDateTimeBuilder get equals => _$this._equals ??= new GDateTimeBuilder();
  set equals(GDateTimeBuilder? equals) => _$this._equals = equals;

  GDateTimeBuilder? _gt;
  GDateTimeBuilder get gt => _$this._gt ??= new GDateTimeBuilder();
  set gt(GDateTimeBuilder? gt) => _$this._gt = gt;

  GDateTimeBuilder? _gte;
  GDateTimeBuilder get gte => _$this._gte ??= new GDateTimeBuilder();
  set gte(GDateTimeBuilder? gte) => _$this._gte = gte;

  ListBuilder<GDateTime>? _Gin;
  ListBuilder<GDateTime> get Gin =>
      _$this._Gin ??= new ListBuilder<GDateTime>();
  set Gin(ListBuilder<GDateTime>? Gin) => _$this._Gin = Gin;

  GDateTimeBuilder? _lt;
  GDateTimeBuilder get lt => _$this._lt ??= new GDateTimeBuilder();
  set lt(GDateTimeBuilder? lt) => _$this._lt = lt;

  GDateTimeBuilder? _lte;
  GDateTimeBuilder get lte => _$this._lte ??= new GDateTimeBuilder();
  set lte(GDateTimeBuilder? lte) => _$this._lte = lte;

  GDateTimeFilterBuilder? _not;
  GDateTimeFilterBuilder get not =>
      _$this._not ??= new GDateTimeFilterBuilder();
  set not(GDateTimeFilterBuilder? not) => _$this._not = not;

  ListBuilder<GDateTime>? _notIn;
  ListBuilder<GDateTime> get notIn =>
      _$this._notIn ??= new ListBuilder<GDateTime>();
  set notIn(ListBuilder<GDateTime>? notIn) => _$this._notIn = notIn;

  GDateTimeFilterBuilder();

  GDateTimeFilterBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _equals = $v.equals?.toBuilder();
      _gt = $v.gt?.toBuilder();
      _gte = $v.gte?.toBuilder();
      _Gin = $v.Gin?.toBuilder();
      _lt = $v.lt?.toBuilder();
      _lte = $v.lte?.toBuilder();
      _not = $v.not?.toBuilder();
      _notIn = $v.notIn?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GDateTimeFilter other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GDateTimeFilter;
  }

  @override
  void update(void Function(GDateTimeFilterBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GDateTimeFilter build() {
    _$GDateTimeFilter _$result;
    try {
      _$result = _$v ??
          new _$GDateTimeFilter._(
              equals: _equals?.build(),
              gt: _gt?.build(),
              gte: _gte?.build(),
              Gin: _Gin?.build(),
              lt: _lt?.build(),
              lte: _lte?.build(),
              not: _not?.build(),
              notIn: _notIn?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'equals';
        _equals?.build();
        _$failedField = 'gt';
        _gt?.build();
        _$failedField = 'gte';
        _gte?.build();
        _$failedField = 'Gin';
        _Gin?.build();
        _$failedField = 'lt';
        _lt?.build();
        _$failedField = 'lte';
        _lte?.build();
        _$failedField = 'not';
        _not?.build();
        _$failedField = 'notIn';
        _notIn?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GDateTimeFilter', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GMomentOrderByInput extends GMomentOrderByInput {
  @override
  final GsortOrder? content;
  @override
  final GsortOrder? createdAt;
  @override
  final GsortOrder? deletedAt;
  @override
  final GsortOrder? id;
  @override
  final GsortOrder? media;
  @override
  final GUserOrderByInput? owner;
  @override
  final GsortOrder? ownerId;
  @override
  final GsortOrder? title;

  factory _$GMomentOrderByInput(
          [void Function(GMomentOrderByInputBuilder)? updates]) =>
      (new GMomentOrderByInputBuilder()..update(updates)).build();

  _$GMomentOrderByInput._(
      {this.content,
      this.createdAt,
      this.deletedAt,
      this.id,
      this.media,
      this.owner,
      this.ownerId,
      this.title})
      : super._();

  @override
  GMomentOrderByInput rebuild(
          void Function(GMomentOrderByInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GMomentOrderByInputBuilder toBuilder() =>
      new GMomentOrderByInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GMomentOrderByInput &&
        content == other.content &&
        createdAt == other.createdAt &&
        deletedAt == other.deletedAt &&
        id == other.id &&
        media == other.media &&
        owner == other.owner &&
        ownerId == other.ownerId &&
        title == other.title;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc($jc($jc(0, content.hashCode), createdAt.hashCode),
                            deletedAt.hashCode),
                        id.hashCode),
                    media.hashCode),
                owner.hashCode),
            ownerId.hashCode),
        title.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GMomentOrderByInput')
          ..add('content', content)
          ..add('createdAt', createdAt)
          ..add('deletedAt', deletedAt)
          ..add('id', id)
          ..add('media', media)
          ..add('owner', owner)
          ..add('ownerId', ownerId)
          ..add('title', title))
        .toString();
  }
}

class GMomentOrderByInputBuilder
    implements Builder<GMomentOrderByInput, GMomentOrderByInputBuilder> {
  _$GMomentOrderByInput? _$v;

  GsortOrder? _content;
  GsortOrder? get content => _$this._content;
  set content(GsortOrder? content) => _$this._content = content;

  GsortOrder? _createdAt;
  GsortOrder? get createdAt => _$this._createdAt;
  set createdAt(GsortOrder? createdAt) => _$this._createdAt = createdAt;

  GsortOrder? _deletedAt;
  GsortOrder? get deletedAt => _$this._deletedAt;
  set deletedAt(GsortOrder? deletedAt) => _$this._deletedAt = deletedAt;

  GsortOrder? _id;
  GsortOrder? get id => _$this._id;
  set id(GsortOrder? id) => _$this._id = id;

  GsortOrder? _media;
  GsortOrder? get media => _$this._media;
  set media(GsortOrder? media) => _$this._media = media;

  GUserOrderByInputBuilder? _owner;
  GUserOrderByInputBuilder get owner =>
      _$this._owner ??= new GUserOrderByInputBuilder();
  set owner(GUserOrderByInputBuilder? owner) => _$this._owner = owner;

  GsortOrder? _ownerId;
  GsortOrder? get ownerId => _$this._ownerId;
  set ownerId(GsortOrder? ownerId) => _$this._ownerId = ownerId;

  GsortOrder? _title;
  GsortOrder? get title => _$this._title;
  set title(GsortOrder? title) => _$this._title = title;

  GMomentOrderByInputBuilder();

  GMomentOrderByInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _content = $v.content;
      _createdAt = $v.createdAt;
      _deletedAt = $v.deletedAt;
      _id = $v.id;
      _media = $v.media;
      _owner = $v.owner?.toBuilder();
      _ownerId = $v.ownerId;
      _title = $v.title;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GMomentOrderByInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GMomentOrderByInput;
  }

  @override
  void update(void Function(GMomentOrderByInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GMomentOrderByInput build() {
    _$GMomentOrderByInput _$result;
    try {
      _$result = _$v ??
          new _$GMomentOrderByInput._(
              content: content,
              createdAt: createdAt,
              deletedAt: deletedAt,
              id: id,
              media: media,
              owner: _owner?.build(),
              ownerId: ownerId,
              title: title);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'owner';
        _owner?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GMomentOrderByInput', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GMomentWhereInput extends GMomentWhereInput {
  @override
  final BuiltList<GMomentWhereInput>? AND;
  @override
  final BuiltList<GMomentWhereInput>? NOT;
  @override
  final BuiltList<GMomentWhereInput>? OR;
  @override
  final GStringFilter? content;
  @override
  final GDateTimeFilter? createdAt;
  @override
  final GStringFilter? id;
  @override
  final GUserRelationFilter? owner;
  @override
  final GStringFilter? ownerId;
  @override
  final GStringFilter? title;

  factory _$GMomentWhereInput(
          [void Function(GMomentWhereInputBuilder)? updates]) =>
      (new GMomentWhereInputBuilder()..update(updates)).build();

  _$GMomentWhereInput._(
      {this.AND,
      this.NOT,
      this.OR,
      this.content,
      this.createdAt,
      this.id,
      this.owner,
      this.ownerId,
      this.title})
      : super._();

  @override
  GMomentWhereInput rebuild(void Function(GMomentWhereInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GMomentWhereInputBuilder toBuilder() =>
      new GMomentWhereInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GMomentWhereInput &&
        AND == other.AND &&
        NOT == other.NOT &&
        OR == other.OR &&
        content == other.content &&
        createdAt == other.createdAt &&
        id == other.id &&
        owner == other.owner &&
        ownerId == other.ownerId &&
        title == other.title;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc(
                            $jc($jc($jc(0, AND.hashCode), NOT.hashCode),
                                OR.hashCode),
                            content.hashCode),
                        createdAt.hashCode),
                    id.hashCode),
                owner.hashCode),
            ownerId.hashCode),
        title.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GMomentWhereInput')
          ..add('AND', AND)
          ..add('NOT', NOT)
          ..add('OR', OR)
          ..add('content', content)
          ..add('createdAt', createdAt)
          ..add('id', id)
          ..add('owner', owner)
          ..add('ownerId', ownerId)
          ..add('title', title))
        .toString();
  }
}

class GMomentWhereInputBuilder
    implements Builder<GMomentWhereInput, GMomentWhereInputBuilder> {
  _$GMomentWhereInput? _$v;

  ListBuilder<GMomentWhereInput>? _AND;
  ListBuilder<GMomentWhereInput> get AND =>
      _$this._AND ??= new ListBuilder<GMomentWhereInput>();
  set AND(ListBuilder<GMomentWhereInput>? AND) => _$this._AND = AND;

  ListBuilder<GMomentWhereInput>? _NOT;
  ListBuilder<GMomentWhereInput> get NOT =>
      _$this._NOT ??= new ListBuilder<GMomentWhereInput>();
  set NOT(ListBuilder<GMomentWhereInput>? NOT) => _$this._NOT = NOT;

  ListBuilder<GMomentWhereInput>? _OR;
  ListBuilder<GMomentWhereInput> get OR =>
      _$this._OR ??= new ListBuilder<GMomentWhereInput>();
  set OR(ListBuilder<GMomentWhereInput>? OR) => _$this._OR = OR;

  GStringFilterBuilder? _content;
  GStringFilterBuilder get content =>
      _$this._content ??= new GStringFilterBuilder();
  set content(GStringFilterBuilder? content) => _$this._content = content;

  GDateTimeFilterBuilder? _createdAt;
  GDateTimeFilterBuilder get createdAt =>
      _$this._createdAt ??= new GDateTimeFilterBuilder();
  set createdAt(GDateTimeFilterBuilder? createdAt) =>
      _$this._createdAt = createdAt;

  GStringFilterBuilder? _id;
  GStringFilterBuilder get id => _$this._id ??= new GStringFilterBuilder();
  set id(GStringFilterBuilder? id) => _$this._id = id;

  GUserRelationFilterBuilder? _owner;
  GUserRelationFilterBuilder get owner =>
      _$this._owner ??= new GUserRelationFilterBuilder();
  set owner(GUserRelationFilterBuilder? owner) => _$this._owner = owner;

  GStringFilterBuilder? _ownerId;
  GStringFilterBuilder get ownerId =>
      _$this._ownerId ??= new GStringFilterBuilder();
  set ownerId(GStringFilterBuilder? ownerId) => _$this._ownerId = ownerId;

  GStringFilterBuilder? _title;
  GStringFilterBuilder get title =>
      _$this._title ??= new GStringFilterBuilder();
  set title(GStringFilterBuilder? title) => _$this._title = title;

  GMomentWhereInputBuilder();

  GMomentWhereInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _AND = $v.AND?.toBuilder();
      _NOT = $v.NOT?.toBuilder();
      _OR = $v.OR?.toBuilder();
      _content = $v.content?.toBuilder();
      _createdAt = $v.createdAt?.toBuilder();
      _id = $v.id?.toBuilder();
      _owner = $v.owner?.toBuilder();
      _ownerId = $v.ownerId?.toBuilder();
      _title = $v.title?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GMomentWhereInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GMomentWhereInput;
  }

  @override
  void update(void Function(GMomentWhereInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GMomentWhereInput build() {
    _$GMomentWhereInput _$result;
    try {
      _$result = _$v ??
          new _$GMomentWhereInput._(
              AND: _AND?.build(),
              NOT: _NOT?.build(),
              OR: _OR?.build(),
              content: _content?.build(),
              createdAt: _createdAt?.build(),
              id: _id?.build(),
              owner: _owner?.build(),
              ownerId: _ownerId?.build(),
              title: _title?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'AND';
        _AND?.build();
        _$failedField = 'NOT';
        _NOT?.build();
        _$failedField = 'OR';
        _OR?.build();
        _$failedField = 'content';
        _content?.build();
        _$failedField = 'createdAt';
        _createdAt?.build();
        _$failedField = 'id';
        _id?.build();
        _$failedField = 'owner';
        _owner?.build();
        _$failedField = 'ownerId';
        _ownerId?.build();
        _$failedField = 'title';
        _title?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GMomentWhereInput', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GMomentWhereUniqueInput extends GMomentWhereUniqueInput {
  @override
  final String? id;

  factory _$GMomentWhereUniqueInput(
          [void Function(GMomentWhereUniqueInputBuilder)? updates]) =>
      (new GMomentWhereUniqueInputBuilder()..update(updates)).build();

  _$GMomentWhereUniqueInput._({this.id}) : super._();

  @override
  GMomentWhereUniqueInput rebuild(
          void Function(GMomentWhereUniqueInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GMomentWhereUniqueInputBuilder toBuilder() =>
      new GMomentWhereUniqueInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GMomentWhereUniqueInput && id == other.id;
  }

  @override
  int get hashCode {
    return $jf($jc(0, id.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GMomentWhereUniqueInput')
          ..add('id', id))
        .toString();
  }
}

class GMomentWhereUniqueInputBuilder
    implements
        Builder<GMomentWhereUniqueInput, GMomentWhereUniqueInputBuilder> {
  _$GMomentWhereUniqueInput? _$v;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  GMomentWhereUniqueInputBuilder();

  GMomentWhereUniqueInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _id = $v.id;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GMomentWhereUniqueInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GMomentWhereUniqueInput;
  }

  @override
  void update(void Function(GMomentWhereUniqueInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GMomentWhereUniqueInput build() {
    final _$result = _$v ?? new _$GMomentWhereUniqueInput._(id: id);
    replace(_$result);
    return _$result;
  }
}

class _$GStringFilter extends GStringFilter {
  @override
  final String? contains;
  @override
  final String? endsWith;
  @override
  final String? equals;
  @override
  final String? gt;
  @override
  final String? gte;
  @override
  final BuiltList<String>? Gin;
  @override
  final String? lt;
  @override
  final String? lte;
  @override
  final GQueryMode? mode;
  @override
  final GStringFilter? not;
  @override
  final BuiltList<String>? notIn;
  @override
  final String? startsWith;

  factory _$GStringFilter([void Function(GStringFilterBuilder)? updates]) =>
      (new GStringFilterBuilder()..update(updates)).build();

  _$GStringFilter._(
      {this.contains,
      this.endsWith,
      this.equals,
      this.gt,
      this.gte,
      this.Gin,
      this.lt,
      this.lte,
      this.mode,
      this.not,
      this.notIn,
      this.startsWith})
      : super._();

  @override
  GStringFilter rebuild(void Function(GStringFilterBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GStringFilterBuilder toBuilder() => new GStringFilterBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GStringFilter &&
        contains == other.contains &&
        endsWith == other.endsWith &&
        equals == other.equals &&
        gt == other.gt &&
        gte == other.gte &&
        Gin == other.Gin &&
        lt == other.lt &&
        lte == other.lte &&
        mode == other.mode &&
        not == other.not &&
        notIn == other.notIn &&
        startsWith == other.startsWith;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc(
                            $jc(
                                $jc(
                                    $jc(
                                        $jc(
                                            $jc($jc(0, contains.hashCode),
                                                endsWith.hashCode),
                                            equals.hashCode),
                                        gt.hashCode),
                                    gte.hashCode),
                                Gin.hashCode),
                            lt.hashCode),
                        lte.hashCode),
                    mode.hashCode),
                not.hashCode),
            notIn.hashCode),
        startsWith.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GStringFilter')
          ..add('contains', contains)
          ..add('endsWith', endsWith)
          ..add('equals', equals)
          ..add('gt', gt)
          ..add('gte', gte)
          ..add('Gin', Gin)
          ..add('lt', lt)
          ..add('lte', lte)
          ..add('mode', mode)
          ..add('not', not)
          ..add('notIn', notIn)
          ..add('startsWith', startsWith))
        .toString();
  }
}

class GStringFilterBuilder
    implements Builder<GStringFilter, GStringFilterBuilder> {
  _$GStringFilter? _$v;

  String? _contains;
  String? get contains => _$this._contains;
  set contains(String? contains) => _$this._contains = contains;

  String? _endsWith;
  String? get endsWith => _$this._endsWith;
  set endsWith(String? endsWith) => _$this._endsWith = endsWith;

  String? _equals;
  String? get equals => _$this._equals;
  set equals(String? equals) => _$this._equals = equals;

  String? _gt;
  String? get gt => _$this._gt;
  set gt(String? gt) => _$this._gt = gt;

  String? _gte;
  String? get gte => _$this._gte;
  set gte(String? gte) => _$this._gte = gte;

  ListBuilder<String>? _Gin;
  ListBuilder<String> get Gin => _$this._Gin ??= new ListBuilder<String>();
  set Gin(ListBuilder<String>? Gin) => _$this._Gin = Gin;

  String? _lt;
  String? get lt => _$this._lt;
  set lt(String? lt) => _$this._lt = lt;

  String? _lte;
  String? get lte => _$this._lte;
  set lte(String? lte) => _$this._lte = lte;

  GQueryMode? _mode;
  GQueryMode? get mode => _$this._mode;
  set mode(GQueryMode? mode) => _$this._mode = mode;

  GStringFilterBuilder? _not;
  GStringFilterBuilder get not => _$this._not ??= new GStringFilterBuilder();
  set not(GStringFilterBuilder? not) => _$this._not = not;

  ListBuilder<String>? _notIn;
  ListBuilder<String> get notIn => _$this._notIn ??= new ListBuilder<String>();
  set notIn(ListBuilder<String>? notIn) => _$this._notIn = notIn;

  String? _startsWith;
  String? get startsWith => _$this._startsWith;
  set startsWith(String? startsWith) => _$this._startsWith = startsWith;

  GStringFilterBuilder();

  GStringFilterBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _contains = $v.contains;
      _endsWith = $v.endsWith;
      _equals = $v.equals;
      _gt = $v.gt;
      _gte = $v.gte;
      _Gin = $v.Gin?.toBuilder();
      _lt = $v.lt;
      _lte = $v.lte;
      _mode = $v.mode;
      _not = $v.not?.toBuilder();
      _notIn = $v.notIn?.toBuilder();
      _startsWith = $v.startsWith;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GStringFilter other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GStringFilter;
  }

  @override
  void update(void Function(GStringFilterBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GStringFilter build() {
    _$GStringFilter _$result;
    try {
      _$result = _$v ??
          new _$GStringFilter._(
              contains: contains,
              endsWith: endsWith,
              equals: equals,
              gt: gt,
              gte: gte,
              Gin: _Gin?.build(),
              lt: lt,
              lte: lte,
              mode: mode,
              not: _not?.build(),
              notIn: _notIn?.build(),
              startsWith: startsWith);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'Gin';
        _Gin?.build();

        _$failedField = 'not';
        _not?.build();
        _$failedField = 'notIn';
        _notIn?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GStringFilter', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GUserOrderByInput extends GUserOrderByInput {
  @override
  final GsortOrder? createdAt;
  @override
  final GsortOrder? id;
  @override
  final GsortOrder? password;
  @override
  final GsortOrder? phone;
  @override
  final GUserProfileOrderByInput? profile;
  @override
  final GsortOrder? username;

  factory _$GUserOrderByInput(
          [void Function(GUserOrderByInputBuilder)? updates]) =>
      (new GUserOrderByInputBuilder()..update(updates)).build();

  _$GUserOrderByInput._(
      {this.createdAt,
      this.id,
      this.password,
      this.phone,
      this.profile,
      this.username})
      : super._();

  @override
  GUserOrderByInput rebuild(void Function(GUserOrderByInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUserOrderByInputBuilder toBuilder() =>
      new GUserOrderByInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUserOrderByInput &&
        createdAt == other.createdAt &&
        id == other.id &&
        password == other.password &&
        phone == other.phone &&
        profile == other.profile &&
        username == other.username;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc($jc($jc(0, createdAt.hashCode), id.hashCode),
                    password.hashCode),
                phone.hashCode),
            profile.hashCode),
        username.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUserOrderByInput')
          ..add('createdAt', createdAt)
          ..add('id', id)
          ..add('password', password)
          ..add('phone', phone)
          ..add('profile', profile)
          ..add('username', username))
        .toString();
  }
}

class GUserOrderByInputBuilder
    implements Builder<GUserOrderByInput, GUserOrderByInputBuilder> {
  _$GUserOrderByInput? _$v;

  GsortOrder? _createdAt;
  GsortOrder? get createdAt => _$this._createdAt;
  set createdAt(GsortOrder? createdAt) => _$this._createdAt = createdAt;

  GsortOrder? _id;
  GsortOrder? get id => _$this._id;
  set id(GsortOrder? id) => _$this._id = id;

  GsortOrder? _password;
  GsortOrder? get password => _$this._password;
  set password(GsortOrder? password) => _$this._password = password;

  GsortOrder? _phone;
  GsortOrder? get phone => _$this._phone;
  set phone(GsortOrder? phone) => _$this._phone = phone;

  GUserProfileOrderByInputBuilder? _profile;
  GUserProfileOrderByInputBuilder get profile =>
      _$this._profile ??= new GUserProfileOrderByInputBuilder();
  set profile(GUserProfileOrderByInputBuilder? profile) =>
      _$this._profile = profile;

  GsortOrder? _username;
  GsortOrder? get username => _$this._username;
  set username(GsortOrder? username) => _$this._username = username;

  GUserOrderByInputBuilder();

  GUserOrderByInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _createdAt = $v.createdAt;
      _id = $v.id;
      _password = $v.password;
      _phone = $v.phone;
      _profile = $v.profile?.toBuilder();
      _username = $v.username;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUserOrderByInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GUserOrderByInput;
  }

  @override
  void update(void Function(GUserOrderByInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUserOrderByInput build() {
    _$GUserOrderByInput _$result;
    try {
      _$result = _$v ??
          new _$GUserOrderByInput._(
              createdAt: createdAt,
              id: id,
              password: password,
              phone: phone,
              profile: _profile?.build(),
              username: username);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'profile';
        _profile?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GUserOrderByInput', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GUserProfileOrderByInput extends GUserProfileOrderByInput {
  @override
  final GsortOrder? avatar;
  @override
  final GsortOrder? bio;
  @override
  final GsortOrder? location;
  @override
  final GsortOrder? name;
  @override
  final GsortOrder? updatedAt;
  @override
  final GsortOrder? userId;

  factory _$GUserProfileOrderByInput(
          [void Function(GUserProfileOrderByInputBuilder)? updates]) =>
      (new GUserProfileOrderByInputBuilder()..update(updates)).build();

  _$GUserProfileOrderByInput._(
      {this.avatar,
      this.bio,
      this.location,
      this.name,
      this.updatedAt,
      this.userId})
      : super._();

  @override
  GUserProfileOrderByInput rebuild(
          void Function(GUserProfileOrderByInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUserProfileOrderByInputBuilder toBuilder() =>
      new GUserProfileOrderByInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUserProfileOrderByInput &&
        avatar == other.avatar &&
        bio == other.bio &&
        location == other.location &&
        name == other.name &&
        updatedAt == other.updatedAt &&
        userId == other.userId;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc($jc($jc(0, avatar.hashCode), bio.hashCode),
                    location.hashCode),
                name.hashCode),
            updatedAt.hashCode),
        userId.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUserProfileOrderByInput')
          ..add('avatar', avatar)
          ..add('bio', bio)
          ..add('location', location)
          ..add('name', name)
          ..add('updatedAt', updatedAt)
          ..add('userId', userId))
        .toString();
  }
}

class GUserProfileOrderByInputBuilder
    implements
        Builder<GUserProfileOrderByInput, GUserProfileOrderByInputBuilder> {
  _$GUserProfileOrderByInput? _$v;

  GsortOrder? _avatar;
  GsortOrder? get avatar => _$this._avatar;
  set avatar(GsortOrder? avatar) => _$this._avatar = avatar;

  GsortOrder? _bio;
  GsortOrder? get bio => _$this._bio;
  set bio(GsortOrder? bio) => _$this._bio = bio;

  GsortOrder? _location;
  GsortOrder? get location => _$this._location;
  set location(GsortOrder? location) => _$this._location = location;

  GsortOrder? _name;
  GsortOrder? get name => _$this._name;
  set name(GsortOrder? name) => _$this._name = name;

  GsortOrder? _updatedAt;
  GsortOrder? get updatedAt => _$this._updatedAt;
  set updatedAt(GsortOrder? updatedAt) => _$this._updatedAt = updatedAt;

  GsortOrder? _userId;
  GsortOrder? get userId => _$this._userId;
  set userId(GsortOrder? userId) => _$this._userId = userId;

  GUserProfileOrderByInputBuilder();

  GUserProfileOrderByInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _avatar = $v.avatar;
      _bio = $v.bio;
      _location = $v.location;
      _name = $v.name;
      _updatedAt = $v.updatedAt;
      _userId = $v.userId;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUserProfileOrderByInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GUserProfileOrderByInput;
  }

  @override
  void update(void Function(GUserProfileOrderByInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUserProfileOrderByInput build() {
    final _$result = _$v ??
        new _$GUserProfileOrderByInput._(
            avatar: avatar,
            bio: bio,
            location: location,
            name: name,
            updatedAt: updatedAt,
            userId: userId);
    replace(_$result);
    return _$result;
  }
}

class _$GUserProfileRelationFilter extends GUserProfileRelationFilter {
  @override
  final GUserProfileWhereInput? Gis;
  @override
  final GUserProfileWhereInput? isNot;

  factory _$GUserProfileRelationFilter(
          [void Function(GUserProfileRelationFilterBuilder)? updates]) =>
      (new GUserProfileRelationFilterBuilder()..update(updates)).build();

  _$GUserProfileRelationFilter._({this.Gis, this.isNot}) : super._();

  @override
  GUserProfileRelationFilter rebuild(
          void Function(GUserProfileRelationFilterBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUserProfileRelationFilterBuilder toBuilder() =>
      new GUserProfileRelationFilterBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUserProfileRelationFilter &&
        Gis == other.Gis &&
        isNot == other.isNot;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, Gis.hashCode), isNot.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUserProfileRelationFilter')
          ..add('Gis', Gis)
          ..add('isNot', isNot))
        .toString();
  }
}

class GUserProfileRelationFilterBuilder
    implements
        Builder<GUserProfileRelationFilter, GUserProfileRelationFilterBuilder> {
  _$GUserProfileRelationFilter? _$v;

  GUserProfileWhereInputBuilder? _Gis;
  GUserProfileWhereInputBuilder get Gis =>
      _$this._Gis ??= new GUserProfileWhereInputBuilder();
  set Gis(GUserProfileWhereInputBuilder? Gis) => _$this._Gis = Gis;

  GUserProfileWhereInputBuilder? _isNot;
  GUserProfileWhereInputBuilder get isNot =>
      _$this._isNot ??= new GUserProfileWhereInputBuilder();
  set isNot(GUserProfileWhereInputBuilder? isNot) => _$this._isNot = isNot;

  GUserProfileRelationFilterBuilder();

  GUserProfileRelationFilterBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _Gis = $v.Gis?.toBuilder();
      _isNot = $v.isNot?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUserProfileRelationFilter other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GUserProfileRelationFilter;
  }

  @override
  void update(void Function(GUserProfileRelationFilterBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUserProfileRelationFilter build() {
    _$GUserProfileRelationFilter _$result;
    try {
      _$result = _$v ??
          new _$GUserProfileRelationFilter._(
              Gis: _Gis?.build(), isNot: _isNot?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'Gis';
        _Gis?.build();
        _$failedField = 'isNot';
        _isNot?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GUserProfileRelationFilter', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GUserProfileUpdateInput extends GUserProfileUpdateInput {
  @override
  final String? avatar;
  @override
  final String? bio;
  @override
  final String? location;
  @override
  final String? name;

  factory _$GUserProfileUpdateInput(
          [void Function(GUserProfileUpdateInputBuilder)? updates]) =>
      (new GUserProfileUpdateInputBuilder()..update(updates)).build();

  _$GUserProfileUpdateInput._({this.avatar, this.bio, this.location, this.name})
      : super._();

  @override
  GUserProfileUpdateInput rebuild(
          void Function(GUserProfileUpdateInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUserProfileUpdateInputBuilder toBuilder() =>
      new GUserProfileUpdateInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUserProfileUpdateInput &&
        avatar == other.avatar &&
        bio == other.bio &&
        location == other.location &&
        name == other.name;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc($jc($jc(0, avatar.hashCode), bio.hashCode), location.hashCode),
        name.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUserProfileUpdateInput')
          ..add('avatar', avatar)
          ..add('bio', bio)
          ..add('location', location)
          ..add('name', name))
        .toString();
  }
}

class GUserProfileUpdateInputBuilder
    implements
        Builder<GUserProfileUpdateInput, GUserProfileUpdateInputBuilder> {
  _$GUserProfileUpdateInput? _$v;

  String? _avatar;
  String? get avatar => _$this._avatar;
  set avatar(String? avatar) => _$this._avatar = avatar;

  String? _bio;
  String? get bio => _$this._bio;
  set bio(String? bio) => _$this._bio = bio;

  String? _location;
  String? get location => _$this._location;
  set location(String? location) => _$this._location = location;

  String? _name;
  String? get name => _$this._name;
  set name(String? name) => _$this._name = name;

  GUserProfileUpdateInputBuilder();

  GUserProfileUpdateInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _avatar = $v.avatar;
      _bio = $v.bio;
      _location = $v.location;
      _name = $v.name;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUserProfileUpdateInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GUserProfileUpdateInput;
  }

  @override
  void update(void Function(GUserProfileUpdateInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUserProfileUpdateInput build() {
    final _$result = _$v ??
        new _$GUserProfileUpdateInput._(
            avatar: avatar, bio: bio, location: location, name: name);
    replace(_$result);
    return _$result;
  }
}

class _$GUserProfileWhereInput extends GUserProfileWhereInput {
  @override
  final BuiltList<GUserProfileWhereInput>? AND;
  @override
  final BuiltList<GUserProfileWhereInput>? NOT;
  @override
  final BuiltList<GUserProfileWhereInput>? OR;
  @override
  final GStringFilter? avatar;
  @override
  final GStringFilter? bio;
  @override
  final GStringFilter? location;
  @override
  final GStringFilter? name;
  @override
  final GUserRelationFilter? user;
  @override
  final GStringFilter? userId;

  factory _$GUserProfileWhereInput(
          [void Function(GUserProfileWhereInputBuilder)? updates]) =>
      (new GUserProfileWhereInputBuilder()..update(updates)).build();

  _$GUserProfileWhereInput._(
      {this.AND,
      this.NOT,
      this.OR,
      this.avatar,
      this.bio,
      this.location,
      this.name,
      this.user,
      this.userId})
      : super._();

  @override
  GUserProfileWhereInput rebuild(
          void Function(GUserProfileWhereInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUserProfileWhereInputBuilder toBuilder() =>
      new GUserProfileWhereInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUserProfileWhereInput &&
        AND == other.AND &&
        NOT == other.NOT &&
        OR == other.OR &&
        avatar == other.avatar &&
        bio == other.bio &&
        location == other.location &&
        name == other.name &&
        user == other.user &&
        userId == other.userId;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc(
                            $jc($jc($jc(0, AND.hashCode), NOT.hashCode),
                                OR.hashCode),
                            avatar.hashCode),
                        bio.hashCode),
                    location.hashCode),
                name.hashCode),
            user.hashCode),
        userId.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUserProfileWhereInput')
          ..add('AND', AND)
          ..add('NOT', NOT)
          ..add('OR', OR)
          ..add('avatar', avatar)
          ..add('bio', bio)
          ..add('location', location)
          ..add('name', name)
          ..add('user', user)
          ..add('userId', userId))
        .toString();
  }
}

class GUserProfileWhereInputBuilder
    implements Builder<GUserProfileWhereInput, GUserProfileWhereInputBuilder> {
  _$GUserProfileWhereInput? _$v;

  ListBuilder<GUserProfileWhereInput>? _AND;
  ListBuilder<GUserProfileWhereInput> get AND =>
      _$this._AND ??= new ListBuilder<GUserProfileWhereInput>();
  set AND(ListBuilder<GUserProfileWhereInput>? AND) => _$this._AND = AND;

  ListBuilder<GUserProfileWhereInput>? _NOT;
  ListBuilder<GUserProfileWhereInput> get NOT =>
      _$this._NOT ??= new ListBuilder<GUserProfileWhereInput>();
  set NOT(ListBuilder<GUserProfileWhereInput>? NOT) => _$this._NOT = NOT;

  ListBuilder<GUserProfileWhereInput>? _OR;
  ListBuilder<GUserProfileWhereInput> get OR =>
      _$this._OR ??= new ListBuilder<GUserProfileWhereInput>();
  set OR(ListBuilder<GUserProfileWhereInput>? OR) => _$this._OR = OR;

  GStringFilterBuilder? _avatar;
  GStringFilterBuilder get avatar =>
      _$this._avatar ??= new GStringFilterBuilder();
  set avatar(GStringFilterBuilder? avatar) => _$this._avatar = avatar;

  GStringFilterBuilder? _bio;
  GStringFilterBuilder get bio => _$this._bio ??= new GStringFilterBuilder();
  set bio(GStringFilterBuilder? bio) => _$this._bio = bio;

  GStringFilterBuilder? _location;
  GStringFilterBuilder get location =>
      _$this._location ??= new GStringFilterBuilder();
  set location(GStringFilterBuilder? location) => _$this._location = location;

  GStringFilterBuilder? _name;
  GStringFilterBuilder get name => _$this._name ??= new GStringFilterBuilder();
  set name(GStringFilterBuilder? name) => _$this._name = name;

  GUserRelationFilterBuilder? _user;
  GUserRelationFilterBuilder get user =>
      _$this._user ??= new GUserRelationFilterBuilder();
  set user(GUserRelationFilterBuilder? user) => _$this._user = user;

  GStringFilterBuilder? _userId;
  GStringFilterBuilder get userId =>
      _$this._userId ??= new GStringFilterBuilder();
  set userId(GStringFilterBuilder? userId) => _$this._userId = userId;

  GUserProfileWhereInputBuilder();

  GUserProfileWhereInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _AND = $v.AND?.toBuilder();
      _NOT = $v.NOT?.toBuilder();
      _OR = $v.OR?.toBuilder();
      _avatar = $v.avatar?.toBuilder();
      _bio = $v.bio?.toBuilder();
      _location = $v.location?.toBuilder();
      _name = $v.name?.toBuilder();
      _user = $v.user?.toBuilder();
      _userId = $v.userId?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUserProfileWhereInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GUserProfileWhereInput;
  }

  @override
  void update(void Function(GUserProfileWhereInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUserProfileWhereInput build() {
    _$GUserProfileWhereInput _$result;
    try {
      _$result = _$v ??
          new _$GUserProfileWhereInput._(
              AND: _AND?.build(),
              NOT: _NOT?.build(),
              OR: _OR?.build(),
              avatar: _avatar?.build(),
              bio: _bio?.build(),
              location: _location?.build(),
              name: _name?.build(),
              user: _user?.build(),
              userId: _userId?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'AND';
        _AND?.build();
        _$failedField = 'NOT';
        _NOT?.build();
        _$failedField = 'OR';
        _OR?.build();
        _$failedField = 'avatar';
        _avatar?.build();
        _$failedField = 'bio';
        _bio?.build();
        _$failedField = 'location';
        _location?.build();
        _$failedField = 'name';
        _name?.build();
        _$failedField = 'user';
        _user?.build();
        _$failedField = 'userId';
        _userId?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GUserProfileWhereInput', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GUserRelationFilter extends GUserRelationFilter {
  @override
  final GUserWhereInput? Gis;
  @override
  final GUserWhereInput? isNot;

  factory _$GUserRelationFilter(
          [void Function(GUserRelationFilterBuilder)? updates]) =>
      (new GUserRelationFilterBuilder()..update(updates)).build();

  _$GUserRelationFilter._({this.Gis, this.isNot}) : super._();

  @override
  GUserRelationFilter rebuild(
          void Function(GUserRelationFilterBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUserRelationFilterBuilder toBuilder() =>
      new GUserRelationFilterBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUserRelationFilter &&
        Gis == other.Gis &&
        isNot == other.isNot;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, Gis.hashCode), isNot.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUserRelationFilter')
          ..add('Gis', Gis)
          ..add('isNot', isNot))
        .toString();
  }
}

class GUserRelationFilterBuilder
    implements Builder<GUserRelationFilter, GUserRelationFilterBuilder> {
  _$GUserRelationFilter? _$v;

  GUserWhereInputBuilder? _Gis;
  GUserWhereInputBuilder get Gis =>
      _$this._Gis ??= new GUserWhereInputBuilder();
  set Gis(GUserWhereInputBuilder? Gis) => _$this._Gis = Gis;

  GUserWhereInputBuilder? _isNot;
  GUserWhereInputBuilder get isNot =>
      _$this._isNot ??= new GUserWhereInputBuilder();
  set isNot(GUserWhereInputBuilder? isNot) => _$this._isNot = isNot;

  GUserRelationFilterBuilder();

  GUserRelationFilterBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _Gis = $v.Gis?.toBuilder();
      _isNot = $v.isNot?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUserRelationFilter other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GUserRelationFilter;
  }

  @override
  void update(void Function(GUserRelationFilterBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUserRelationFilter build() {
    _$GUserRelationFilter _$result;
    try {
      _$result = _$v ??
          new _$GUserRelationFilter._(
              Gis: _Gis?.build(), isNot: _isNot?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'Gis';
        _Gis?.build();
        _$failedField = 'isNot';
        _isNot?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GUserRelationFilter', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GUserWhereInput extends GUserWhereInput {
  @override
  final BuiltList<GUserWhereInput>? AND;
  @override
  final BuiltList<GUserWhereInput>? NOT;
  @override
  final BuiltList<GUserWhereInput>? OR;
  @override
  final GDateTimeFilter? createdAt;
  @override
  final GStringFilter? id;
  @override
  final GUserProfileRelationFilter? moments;
  @override
  final GStringFilter? phone;
  @override
  final GUserProfileRelationFilter? profile;
  @override
  final GStringFilter? username;

  factory _$GUserWhereInput([void Function(GUserWhereInputBuilder)? updates]) =>
      (new GUserWhereInputBuilder()..update(updates)).build();

  _$GUserWhereInput._(
      {this.AND,
      this.NOT,
      this.OR,
      this.createdAt,
      this.id,
      this.moments,
      this.phone,
      this.profile,
      this.username})
      : super._();

  @override
  GUserWhereInput rebuild(void Function(GUserWhereInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUserWhereInputBuilder toBuilder() =>
      new GUserWhereInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUserWhereInput &&
        AND == other.AND &&
        NOT == other.NOT &&
        OR == other.OR &&
        createdAt == other.createdAt &&
        id == other.id &&
        moments == other.moments &&
        phone == other.phone &&
        profile == other.profile &&
        username == other.username;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc(
                            $jc($jc($jc(0, AND.hashCode), NOT.hashCode),
                                OR.hashCode),
                            createdAt.hashCode),
                        id.hashCode),
                    moments.hashCode),
                phone.hashCode),
            profile.hashCode),
        username.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUserWhereInput')
          ..add('AND', AND)
          ..add('NOT', NOT)
          ..add('OR', OR)
          ..add('createdAt', createdAt)
          ..add('id', id)
          ..add('moments', moments)
          ..add('phone', phone)
          ..add('profile', profile)
          ..add('username', username))
        .toString();
  }
}

class GUserWhereInputBuilder
    implements Builder<GUserWhereInput, GUserWhereInputBuilder> {
  _$GUserWhereInput? _$v;

  ListBuilder<GUserWhereInput>? _AND;
  ListBuilder<GUserWhereInput> get AND =>
      _$this._AND ??= new ListBuilder<GUserWhereInput>();
  set AND(ListBuilder<GUserWhereInput>? AND) => _$this._AND = AND;

  ListBuilder<GUserWhereInput>? _NOT;
  ListBuilder<GUserWhereInput> get NOT =>
      _$this._NOT ??= new ListBuilder<GUserWhereInput>();
  set NOT(ListBuilder<GUserWhereInput>? NOT) => _$this._NOT = NOT;

  ListBuilder<GUserWhereInput>? _OR;
  ListBuilder<GUserWhereInput> get OR =>
      _$this._OR ??= new ListBuilder<GUserWhereInput>();
  set OR(ListBuilder<GUserWhereInput>? OR) => _$this._OR = OR;

  GDateTimeFilterBuilder? _createdAt;
  GDateTimeFilterBuilder get createdAt =>
      _$this._createdAt ??= new GDateTimeFilterBuilder();
  set createdAt(GDateTimeFilterBuilder? createdAt) =>
      _$this._createdAt = createdAt;

  GStringFilterBuilder? _id;
  GStringFilterBuilder get id => _$this._id ??= new GStringFilterBuilder();
  set id(GStringFilterBuilder? id) => _$this._id = id;

  GUserProfileRelationFilterBuilder? _moments;
  GUserProfileRelationFilterBuilder get moments =>
      _$this._moments ??= new GUserProfileRelationFilterBuilder();
  set moments(GUserProfileRelationFilterBuilder? moments) =>
      _$this._moments = moments;

  GStringFilterBuilder? _phone;
  GStringFilterBuilder get phone =>
      _$this._phone ??= new GStringFilterBuilder();
  set phone(GStringFilterBuilder? phone) => _$this._phone = phone;

  GUserProfileRelationFilterBuilder? _profile;
  GUserProfileRelationFilterBuilder get profile =>
      _$this._profile ??= new GUserProfileRelationFilterBuilder();
  set profile(GUserProfileRelationFilterBuilder? profile) =>
      _$this._profile = profile;

  GStringFilterBuilder? _username;
  GStringFilterBuilder get username =>
      _$this._username ??= new GStringFilterBuilder();
  set username(GStringFilterBuilder? username) => _$this._username = username;

  GUserWhereInputBuilder();

  GUserWhereInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _AND = $v.AND?.toBuilder();
      _NOT = $v.NOT?.toBuilder();
      _OR = $v.OR?.toBuilder();
      _createdAt = $v.createdAt?.toBuilder();
      _id = $v.id?.toBuilder();
      _moments = $v.moments?.toBuilder();
      _phone = $v.phone?.toBuilder();
      _profile = $v.profile?.toBuilder();
      _username = $v.username?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUserWhereInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GUserWhereInput;
  }

  @override
  void update(void Function(GUserWhereInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUserWhereInput build() {
    _$GUserWhereInput _$result;
    try {
      _$result = _$v ??
          new _$GUserWhereInput._(
              AND: _AND?.build(),
              NOT: _NOT?.build(),
              OR: _OR?.build(),
              createdAt: _createdAt?.build(),
              id: _id?.build(),
              moments: _moments?.build(),
              phone: _phone?.build(),
              profile: _profile?.build(),
              username: _username?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'AND';
        _AND?.build();
        _$failedField = 'NOT';
        _NOT?.build();
        _$failedField = 'OR';
        _OR?.build();
        _$failedField = 'createdAt';
        _createdAt?.build();
        _$failedField = 'id';
        _id?.build();
        _$failedField = 'moments';
        _moments?.build();
        _$failedField = 'phone';
        _phone?.build();
        _$failedField = 'profile';
        _profile?.build();
        _$failedField = 'username';
        _username?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GUserWhereInput', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GUserWhereUniqueInput extends GUserWhereUniqueInput {
  @override
  final String? id;
  @override
  final String? phone;
  @override
  final String? username;

  factory _$GUserWhereUniqueInput(
          [void Function(GUserWhereUniqueInputBuilder)? updates]) =>
      (new GUserWhereUniqueInputBuilder()..update(updates)).build();

  _$GUserWhereUniqueInput._({this.id, this.phone, this.username}) : super._();

  @override
  GUserWhereUniqueInput rebuild(
          void Function(GUserWhereUniqueInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUserWhereUniqueInputBuilder toBuilder() =>
      new GUserWhereUniqueInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUserWhereUniqueInput &&
        id == other.id &&
        phone == other.phone &&
        username == other.username;
  }

  @override
  int get hashCode {
    return $jf(
        $jc($jc($jc(0, id.hashCode), phone.hashCode), username.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUserWhereUniqueInput')
          ..add('id', id)
          ..add('phone', phone)
          ..add('username', username))
        .toString();
  }
}

class GUserWhereUniqueInputBuilder
    implements Builder<GUserWhereUniqueInput, GUserWhereUniqueInputBuilder> {
  _$GUserWhereUniqueInput? _$v;

  String? _id;
  String? get id => _$this._id;
  set id(String? id) => _$this._id = id;

  String? _phone;
  String? get phone => _$this._phone;
  set phone(String? phone) => _$this._phone = phone;

  String? _username;
  String? get username => _$this._username;
  set username(String? username) => _$this._username = username;

  GUserWhereUniqueInputBuilder();

  GUserWhereUniqueInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _id = $v.id;
      _phone = $v.phone;
      _username = $v.username;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUserWhereUniqueInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GUserWhereUniqueInput;
  }

  @override
  void update(void Function(GUserWhereUniqueInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUserWhereUniqueInput build() {
    final _$result = _$v ??
        new _$GUserWhereUniqueInput._(id: id, phone: phone, username: username);
    replace(_$result);
    return _$result;
  }
}

// ignore_for_file: always_put_control_body_on_new_line,always_specify_types,annotate_overrides,avoid_annotating_with_dynamic,avoid_as,avoid_catches_without_on_clauses,avoid_returning_this,lines_longer_than_80_chars,omit_local_variable_types,prefer_expression_function_bodies,sort_constructors_first,test_types_in_equals,unnecessary_const,unnecessary_new
